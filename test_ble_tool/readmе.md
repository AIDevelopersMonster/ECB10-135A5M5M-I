Отлично, фиксируем результат и **закрываем BLE-этап правильно**. Ниже — готовый `README.md`, в инженерном стиле, без воды, отражает **что реально сделали**, **что работает**, и **что логично делать дальше**.

Ты можешь **прямо так сохранить файл** как `README.md` в папке BLE.

---

````md
# BLE (Bluetooth Low Energy) — текущий статус и дальнейшие шаги

## Цель этапа

На данном этапе задача состояла **не в реализации полноценного BLE-приложения**,  
а в том, чтобы:

- проверить работоспособность Bluetooth-стека на плате
- добиться **реального появления платы в BLE-сканере телефона (nRF Connect)**
- зафиксировать **минимальный, стабильный и воспроизводимый сценарий**
- интегрировать этот сценарий в GUI **без падений и побочных эффектов**

---

## Что за среда используется

- Плата: **EBYTE STM32MP135**
- ОС: Embedded Linux (BusyBox / Buildroot-подобная)
- BlueZ: **5.63**
- Управление: `bluetoothctl`
- Телефон: Android + **nRF Connect**

---

## Ключевое наблюдение

BLE-устройство **появляется в BLE-сканере телефона только при корректно
настроенном advertising-профиле**.

Простая команда:

```sh
bluetoothctl advertise on
````

— **включает advertising**,
но **по умолчанию без имени** (`Name: off`),
из-за чего устройство **часто не отображается в nRF Connect**.

Следовательно, **обязателен шаг задания имени** через `menu advertise`.

---

## Рабочий сценарий (проверен вручную и через GUI)

### Запуск BLE advertising

Последовательность команд **строго важна**:

```text
bluetoothctl
power on
menu advertise
name EBYTE_BLE
back
advertise on
```

Результат:

* BLE advertising активен
* устройство видно в **nRF Connect**
* отображается с именем **EBYTE_BLE**

---

### Остановка BLE

```text
advertise off
power off
exit
```

---

## Реализация в GUI

В проекте реализована **интерактивная BLE-вкладка**, которая:

* **не использует пайпы (`|`)**
* **не запускает новые процессы bluetoothctl**
* работает с **одной интерактивной сессией**, как в терминале
* повторяет ручной сценарий **кнопка в кнопку**
* **не падает** при запуске и использовании

### Кнопки расположены в логическом порядке:

#### Start BLE

1. `bluetoothctl (enter)`
2. `power on`
3. `menu advertise`
4. `name EBYTE_BLE`
5. `back`
6. `advertise on`

#### Stop BLE

1. `advertise off`
2. `power off`
3. `exit`

#### Service

* `Clear output` — очистка окна вывода

Такой подход позволяет:

* пошагово демонстрировать BLE в видео
* вручную контролировать состояние
* легко диагностировать проблемы без скрытой логики

---

## Что сознательно НЕ делалось на этом этапе

Это важно зафиксировать:

* ❌ не запускался GATT-сервер
* ❌ не использовались Python-скрипты BlueZ
* ❌ не добавлялись сервисы и характеристики
* ❌ не модифицировался systemd / bluetoothd
* ❌ не производилась сборка нового rootfs

Причина: текущий образ **не содержит `python-dbus`**,
а цель этапа — **проверка BLE-стека и advertising**, а не приложения.

---

## Что уже подтверждено как рабочее

* Bluetooth-контроллер работает
* BLE advertising включается
* Имя корректно передаётся в рекламе
* Плата обнаруживается в nRF Connect
* GUI-интеграция стабильна

Этот этап можно считать **PASS**.

---

## Логичные следующие шаги

Дальнейшее развитие возможно по нескольким направлениям:

### 1. Автоматизация

* кнопка **AUTO START BLE**
* кнопка **AUTO STOP BLE**

### 2. GATT

* добавление `python-dbus` в образ
* запуск `example-gatt-server`
* проверка сервисов и характеристик в nRF Connect

### 3. Диагностика

* вкладка `BLE Status (read-only)`
* `bluetoothctl show`
* `hciconfig -a`
* `btmon`

### 4. Документация

* отдельный `BLE_QUICK_TEST.md`
* сценарий для видео
* чеклист для производства

---

## Итог

BLE-этап успешно завершён:

* получен **реальный, наблюдаемый результат**
* зафиксирован **рабочий минимум**
* создана **стабильная GUI-вкладка**
* определены **чёткие точки роста**

Дальнейшее развитие возможно **без переделки текущей реализации**.

```


